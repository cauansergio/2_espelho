<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulação de Espelhos Angulares</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        header {
            background-color: #2c3e50;
            color: white;
            width: 100%;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            position: relative;
        }

        h1 { margin: 0; font-size: 1.5rem; }

        .developer-note {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 0.9rem;
            color: #ecf0f1;
            font-style: italic;
        }

        .main-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 95%;
            flex: 1;
        }

        .canvas-container {
            flex: 2;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .controls-panel {
            flex: 1;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            overflow-y: auto;
        }

        .info-box {
            background-color: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            border-radius: 4px;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .formula-display {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #333;
            white-space: pre-wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #444;
            display: flex;
            justify-content: space-between;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .exact-input-group {
            display: flex;
            gap: 10px;
            margin-top: 5px;
        }

        .exact-input-group input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .exact-input-group button {
            padding: 8px 15px;
            background-color: #4caf50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
        }

        .exact-input-group button:hover {
            background-color: #43a047;
        }

        .buttons-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            flex: 1;
        }

        button.btn-bisector {
            background-color: #4caf50;
            color: white;
        }
        button.btn-bisector:hover { background-color: #43a047; }

        button.btn-reset {
            background-color: #9e9e9e;
            color: white;
        }
        button.btn-reset:hover { background-color: #757575; }

        .warning-box {
            background-color: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            color: #856404;
            display: none;
            margin-top: 10px;
        }

        .parity-info {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            font-size: 0.85rem;
            margin-top: 5px;
        }

        @media (max-width: 800px) {
            .main-container { flex-direction: column; }
            .canvas-container { height: 400px; }
            .developer-note {
                position: static;
                transform: none;
                text-align: center;
                margin-top: 5px;
            }
        }
    </style>
</head>
<body>

<header>
    <h1>Simulação de dois espelhos planos</h1>
    <div class="developer-note">Desenvolvido por Cauan Sergio</div>
</header>

<div class="main-container">
    <div class="canvas-container" id="canvasWrapper">
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="controls-panel">
        <div class="info-box">
            <div id="statsInfo"></div>
            <hr style="border: 0; border-top: 1px solid #bdc3c7; margin: 10px 0;">
            <div class="formula-display" id="formulaInfo"></div>
            <div class="warning-box" id="warningBox"></div>
        </div>

        <div class="control-group">
            <label>
                Ângulo entre espelhos (&theta;)
                <span id="valTheta">60°</span>
            </label>
            <input type="range" id="sliderTheta" min="0" max="180" value="60" step="1">
            
            <div class="exact-input-group">
                <input type="number" id="exactTheta" min="0" max="180" step="1" placeholder="Digite ângulo exato">
                <button id="btnExactTheta">Aplicar</button>
            </div>
        </div>

        <div class="control-group">
            <label>
                Ângulo do Objeto
                <span id="valObjAngle">30°</span>
            </label>
            <input type="range" id="sliderObjAngle" min="0" max="60" value="30" step="0.5">
        </div>

        <div class="control-group">
            <label>
                Distância (Raio)
                <span id="valRadius">3.0</span>
            </label>
            <input type="range" id="sliderRadius" min="0.5" max="4.5" value="3.0" step="0.1">
        </div>

        <div class="buttons-row">
            <button class="btn-bisector" id="btnBisector">Colocar na Bissetriz</button>
            <button class="btn-reset" id="btnReset">Resetar</button>
        </div>
    </div>
</div>

<script>
    // --- Configuração e Estado ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvasWrapper');

    // Elementos da UI
    const sliderTheta = document.getElementById('sliderTheta');
    const sliderObjAngle = document.getElementById('sliderObjAngle');
    const sliderRadius = document.getElementById('sliderRadius');
    const exactTheta = document.getElementById('exactTheta');
    const btnExactTheta = document.getElementById('btnExactTheta');
    const valTheta = document.getElementById('valTheta');
    const valObjAngle = document.getElementById('valObjAngle');
    const valRadius = document.getElementById('valRadius');
    const statsInfo = document.getElementById('statsInfo');
    const formulaInfo = document.getElementById('formulaInfo');
    const warningBox = document.getElementById('warningBox');
    const parityInfo = document.getElementById('parityInfo');
    const btnBisector = document.getElementById('btnBisector');
    const btnReset = document.getElementById('btnReset');

    // Estado da simulação
    let state = {
        thetaDeg: 60,
        objAngleDeg: 30,
        radius: 3.0,
        scale: 40, // Pixels por unidade
        width: 0,
        height: 0
    };

    // --- Funções Matemáticas Auxiliares ---

    function toRadians(deg) { return deg * Math.PI / 180; }
    function toDegrees(rad) { return rad * 180 / Math.PI; }

    function isOnBisector(objAngle, theta) {
        const bisector = theta / 2.0;
        // Tolerância de 0.5 graus
        return Math.abs(objAngle - bisector) < 0.5;
    }

    // Lógica principal de contagem de imagens CORRIGIDA
    function calculateNumberOfImages(thetaDeg, objOnBisector) {
        // Caso especial: θ = 0° (espelhos paralelos) → infinitas imagens
        if (thetaDeg === 0) {
            return { 
                N: Infinity, 
                formula: "θ = 0°\nEspelhos paralelos\nN = ∞ (infinitas imagens)",
                isExactDivisor: false,
                infiniteImages: true,
                parity: "N/A"
            };
        }
        
        const ratio = 360.0 / thetaDeg;
        const N_int = Math.floor(ratio); // Parte inteira de 360/θ
        
        // Determinar paridade baseado na parte inteira
        const isIntPartOdd = (N_int % 2 === 1);
        const parity = isIntPartOdd ? "ímpar" : "par";
        
        // Verifica se é divisor exato (360/θ é inteiro)
        const isExactDivisor = Math.abs(ratio - N_int) < 1e-10;
        
        let N, formula;

        if (isExactDivisor) {
            // Caso 1: 360/θ é inteiro
            // Determinar paridade baseado no valor inteiro
            if (N_int % 2 === 0) {
                // N é PAR: N = (360/θ) - 1
                N = N_int - 1;
                formula = `360°/${thetaDeg}° = ${N_int} (inteiro par)\nN = ${N_int} - 1 = ${N}`;
            } else {
                // N é ÍMPAR
                if (objOnBisector) {
                    // Na bissetriz: N = (360/θ) - 1
                    N = N_int - 1;
                    formula = `360°/${thetaDeg}° = ${N_int} (inteiro ímpar)\nObjeto NA bissetriz\nN = ${N_int} - 1 = ${N}`;
                } else {
                    // Fora da bissetriz: N = 360/θ
                    N = N_int;
                    formula = `360°/${thetaDeg}° = ${N_int} (inteiro ímpar)\nObjeto FORA da bissetriz\nN = ${N_int}`;
                }
            }
        } else {
            // Caso 2: 360/θ NÃO é inteiro
            // Usar paridade baseada na parte inteira
            if (isIntPartOdd) {
                // Parte inteira é ÍMPAR
                if (objOnBisector) {
                    // Na bissetriz: N = floor(360/θ) - 1
                    N = N_int - 1;
                    formula = `360°/${thetaDeg}° ≈ ${ratio.toFixed(2)}\nParte inteira = ${N_int} (ímpar)\nObjeto NA bissetriz\nN = ${N_int} - 1 = ${N}`;
                } else {
                    // Fora da bissetriz: N = floor(360/θ)
                    N = N_int;
                    formula = `360°/${thetaDeg}° ≈ ${ratio.toFixed(2)}\nParte inteira = ${N_int} (ímpar)\nObjeto FORA da bissetriz\nN = ${N_int}`;
                }
            } else {
                // Parte inteira é PAR: N = floor(360/θ) - 1
                N = N_int - 1;
                formula = `360°/${thetaDeg}° ≈ ${ratio.toFixed(2)}\nParte inteira = ${N_int} (par)\nN = ${N_int} - 1 = ${N}`;
            }
        }

        return { 
            N, 
            formula, 
            isExactDivisor, 
            infiniteImages: false,
            parity,
            ratio: ratio,
            intPart: N_int
        };
    }

    // --- Motor de Física (Reflexões) ---

    function calculateAllImages() {
        const thetaRad = toRadians(state.thetaDeg);
        const objRad = toRadians(state.objAngleDeg);
        
        // Posição do objeto original
        const objX = state.radius * Math.cos(objRad);
        const objY = state.radius * Math.sin(objRad);

        const onBisector = isOnBisector(state.objAngleDeg, state.thetaDeg);
        const { N: N_theory, formula, infiniteImages, parity, ratio, intPart } = calculateNumberOfImages(state.thetaDeg, onBisector);

        // Caso especial: θ = 0° (infinitas imagens)
        if (infiniteImages) {
            // Para demonstração, mostramos apenas algumas imagens
            const demoImages = [];
            const maxDemoImages = 12; // Número máximo de imagens para mostrar
            
            // Gera algumas imagens para demonstração
            for (let i = 1; i <= maxDemoImages; i++) {
                const angle = objRad + (i * Math.PI); // Reflexões alternadas
                const x = state.radius * Math.cos(angle);
                const y = state.radius * Math.sin(angle);
                demoImages.push({x, y, angle});
            }
            
            return { 
                images: demoImages, 
                N_theory: Infinity, 
                formula, 
                onBisector, 
                obj: {x: objX, y: objY},
                infiniteImages: true,
                parity: "N/A"
            };
        }

        if (N_theory <= 0) {
            return { 
                images: [], 
                N_theory, 
                formula, 
                onBisector, 
                obj: {x: objX, y: objY}, 
                infiniteImages: false,
                parity
            };
        }

        // BFS para encontrar imagens
        let images = [];
        let imageSet = new Set(); // Para evitar duplicatas baseada em string de coords arredondadas
        
        // Adiciona objeto ao set para não duplicar com ele mesmo
        const key = (x, y) => `${x.toFixed(4)},${y.toFixed(4)}`;
        imageSet.add(key(objX, objY));

        // Fila de processamento: [x, y, angulo_atual]
        // Angulo atual é o ângulo polar do ponto
        let toProcess = [{x: objX, y: objY, angle: objRad}];
        
        const mirror1Angle = 0;
        const mirror2Angle = thetaRad;

        let safetyCount = 0;
        
        // Loop até encontrar o número teórico ou esgotar reflexões possíveis
        while (images.length < N_theory && toProcess.length > 0 && safetyCount < 1000) {
            const current = toProcess.shift();
            safetyCount++;

            // Tenta refletir nos dois espelhos
            // Fórmulas de reflexão polar: novo_angulo = 2*angulo_espelho - angulo_atual
            
            const reflections = [
                { mAngle: mirror1Angle },
                { mAngle: mirror2Angle }
            ];

            reflections.forEach(ref => {
                const newAngle = 2 * ref.mAngle - current.angle;
                // Normaliza ângulo
                const xNew = state.radius * Math.cos(newAngle);
                const yNew = state.radius * Math.sin(newAngle);
                
                const k = key(xNew, yNew);
                
                if (!imageSet.has(k)) {
                    // Verifica se não é o objeto original (redundância por segurança float)
                    const distToObj = Math.hypot(xNew - objX, yNew - objY);
                    
                    if (distToObj > 1e-4) {
                        imageSet.add(k);
                        const newImg = {x: xNew, y: yNew, angle: newAngle};
                        images.push(newImg);
                        toProcess.push(newImg); // Adiciona na fila para gerar reflexões de ordem superior
                    }
                }
            });
        }

        // Limita ao número teórico (física real vs artefatos numéricos)
        if (images.length > N_theory) {
            images = images.slice(0, N_theory);
        }

        return { 
            images, 
            N_theory, 
            formula, 
            onBisector, 
            obj: {x: objX, y: objY}, 
            infiniteImages: false,
            parity,
            ratio,
            intPart
        };
    }

    // --- Renderização ---

    // Converte coordenadas do mundo (física) para coordenadas do canvas
    function worldToScreen(x, y) {
        const cx = state.width / 2;
        const cy = state.height / 2;
        return {
            x: cx + x * state.scale,
            y: cy - y * state.scale // Y invertido no canvas
        };
    }

    function drawGrid() {
        const cx = state.width / 2;
        const cy = state.height / 2;
        
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        
        // Grid lines
        const step = state.scale;
        
        // Verticais
        for (let x = cx % step; x < state.width; x += step) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.height); ctx.stroke();
        }
        // Horizontais
        for (let y = cy % step; y < state.height; y += step) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.width, y); ctx.stroke();
        }

        // Eixos X e Y
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(state.width, cy); ctx.stroke(); // X
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, state.height); ctx.stroke(); // Y
        
        // Marcador de origem
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
    }

    function drawMirrors() {
        const center = worldToScreen(0, 0);
        const length = 5; // Comprimento visual do espelho

        // Espelho 1 (Fixo no eixo X positivo)
        const m1End = worldToScreen(length, 0);
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(m1End.x, m1End.y);
        ctx.stroke();
        
        // Texto M1
        ctx.fillStyle = 'blue';
        ctx.font = 'bold 14px Arial';
        ctx.fillText("Espelho 1", m1End.x - 60, m1End.y + 20);

        // Espelho 2 (apenas se θ > 0)
        if (state.thetaDeg > 0) {
            const thetaRad = toRadians(state.thetaDeg);
            const m2x = length * Math.cos(thetaRad);
            const m2y = length * Math.sin(thetaRad);
            const m2End = worldToScreen(m2x, m2y);
            
            ctx.strokeStyle = 'red';
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(m2End.x, m2End.y);
            ctx.stroke();

            // Texto M2
            ctx.fillStyle = 'red';
            ctx.fillText("Espelho 2", m2End.x + 5, m2End.y);

            // Bissetriz (apenas se θ > 0)
            const bisAngle = thetaRad / 2;
            const bx = (length - 1) * Math.cos(bisAngle);
            const by = (length - 1) * Math.sin(bisAngle);
            const bEnd = worldToScreen(bx, by);

            ctx.strokeStyle = 'green';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(center.x, center.y);
            ctx.lineTo(bEnd.x, bEnd.y);
            ctx.stroke();
            ctx.setLineDash([]);
            
            ctx.fillStyle = 'green';
            ctx.font = '12px Arial';
            ctx.fillText("Bissetriz", bEnd.x + 5, bEnd.y);
        }
    }

    function drawScene() {
        // Limpar
        ctx.clearRect(0, 0, state.width, state.height);
        
        drawGrid();
        drawMirrors();

        // Calcular Física
        const data = calculateAllImages();
        
        // Desenhar Imagens como círculos amarelos
        data.images.forEach((img, index) => {
            const pos = worldToScreen(img.x, img.y);
            
            // Círculo amarelo para imagem
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 8, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 235, 59, 0.8)'; // Amarelo
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#ff9800'; // Laranja
            ctx.stroke();
            
            // Número dentro do círculo (apenas se não for infinitas imagens)
            if (!data.infiniteImages) {
                ctx.fillStyle = 'black';
                ctx.font = 'bold 10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(index + 1, pos.x, pos.y);
            } else {
                // Para infinitas imagens, mostra reticências
                if (index === data.images.length - 1) {
                    ctx.fillStyle = 'red';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText("...", pos.x, pos.y);
                }
            }
        });

        // Desenhar Objeto Original (círculo vermelho)
        const objPos = worldToScreen(data.obj.x, data.obj.y);
        ctx.beginPath();
        ctx.arc(objPos.x, objPos.y, 10, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(244, 67, 54, 0.9)'; // Vermelho
        ctx.fill();
        ctx.lineWidth = 3;
        ctx.strokeStyle = 'darkred';
        ctx.stroke();
        
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText("O", objPos.x, objPos.y);

        // Atualizar UI de Texto
        updateInfoPanel(data);
    }

    function updateInfoPanel(data) {
        if (state.thetaDeg === 0) {
            statsInfo.innerHTML = `
                <strong>Ângulo entre espelhos:</strong> 0°<br>
                <strong>Ângulo do Objeto:</strong> ${state.objAngleDeg.toFixed(1)}°<br>
                <strong>Na bissetriz:</strong> N/A<br>
                <br>
                <strong>Imagens Teóricas (N):</strong> ∞ (infinitas)<br>
                <strong>Imagens Visíveis:</strong> ${data.images.length} (demonstração)
            `;
            
            warningBox.style.display = 'block';
            warningBox.innerHTML = `
                <strong>⚠ Caso Especial: Espelhos Paralelos</strong><br>
                Quando θ = 0°, os espelhos estão paralelos.<br>
                Neste caso, formam-se infinitas imagens.
            `;
        } else {
            statsInfo.innerHTML = `
                <strong>Ângulo entre espelhos:</strong> ${state.thetaDeg}°<br>
                <strong>360/θ:</strong> ${data.ratio.toFixed(2)}<br>
                <strong>Parte inteira:</strong> ${data.intPart} (${data.parity})<br>
                <strong>Ângulo do Objeto:</strong> ${state.objAngleDeg.toFixed(1)}°<br>
                <strong>Na bissetriz:</strong> ${data.onBisector ? '<span style="color:green; font-weight:bold">SIM</span>' : 'NÃO'}<br>
                <br>
                <strong>Imagens Teóricas (N):</strong> ${data.infiniteImages ? '∞' : data.N_theory}<br>
                <strong>Imagens Visíveis:</strong> ${data.images.length}
            `;
            
            warningBox.style.display = 'none';
        }
        
        formulaInfo.innerText = data.formula;
    }

    // --- Função para limitar o ângulo do objeto ---
    function updateObjectAngleLimit() {
        const maxObjAngle = state.thetaDeg;
        const currentObjAngle = parseFloat(sliderObjAngle.value);
        
        // Atualiza o máximo do slider
        sliderObjAngle.max = maxObjAngle;
        
        // Ajusta o valor se estiver acima do novo máximo
        if (currentObjAngle > maxObjAngle) {
            sliderObjAngle.value = maxObjAngle;
        }
        
        // Atualiza o estado
        state.objAngleDeg = parseFloat(sliderObjAngle.value);
        valObjAngle.textContent = state.objAngleDeg.toFixed(1) + "°";
    }

    // --- Função para aplicar ângulo exato ---
    function applyExactTheta() {
        const value = parseInt(exactTheta.value);
        
        if (value >= 0 && value <= 180) {
            // Atualiza o slider e o estado
            sliderTheta.value = value;
            state.thetaDeg = value;
            valTheta.textContent = value + "°";
            
            // Limpa o campo de entrada
            exactTheta.value = '';
            
            // Atualiza limite do ângulo do objeto
            updateObjectAngleLimit();
            
            // Redesenha a cena
            drawScene();
        } else {
            alert("Por favor, digite um valor entre 0 e 180 graus.");
            exactTheta.focus();
        }
    }

    // --- Manipuladores de Eventos ---

    function resize() {
        // Ajusta tamanho do canvas ao container
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        state.width = rect.width;
        state.height = rect.height;
        
        // Ajusta escala baseada no menor lado
        state.scale = Math.min(state.width, state.height) / 11; // -5 a +5 = 10 unidades + margem
        
        drawScene();
    }

    function updateParams() {
        state.thetaDeg = parseInt(sliderTheta.value);
        
        // Atualiza limite do ângulo do objeto
        updateObjectAngleLimit();
        
        state.radius = parseFloat(sliderRadius.value);

        // Atualiza labels
        valTheta.textContent = state.thetaDeg + "°";
        valRadius.textContent = state.radius.toFixed(1);

        drawScene();
    }

    // Listeners Sliders
    sliderTheta.addEventListener('input', updateParams);
    sliderObjAngle.addEventListener('input', updateParams);
    sliderRadius.addEventListener('input', updateParams);

    // Listener para entrada exata
    btnExactTheta.addEventListener('click', applyExactTheta);
    
    // Permitir Enter na entrada exata
    exactTheta.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            applyExactTheta();
        }
    });

    // Listeners Botões
    btnBisector.addEventListener('click', () => {
        const newAngle = state.thetaDeg / 2.0;
        sliderObjAngle.value = newAngle;
        updateParams();
    });

    btnReset.addEventListener('click', () => {
        sliderTheta.value = 60;
        sliderObjAngle.value = 30;
        sliderRadius.value = 3.0;
        exactTheta.value = '';
        updateParams();
    });

    window.addEventListener('resize', resize);

    // Inicialização
    resize(); // Configura tamanho inicial e desenha
    updateParams(); // Garante sincronia inicial

</script>

</body>
</html>

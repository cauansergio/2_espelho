<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulação de Espelhos Angulares</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
        }

        header {
            background-color: #2c3e50;
            color: white;
            width: 100%;
            padding: 15px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        h1 { margin: 0; font-size: 1.5rem; }

        .main-container {
            display: flex;
            flex-direction: row;
            gap: 20px;
            padding: 20px;
            max-width: 1200px;
            width: 95%;
            flex: 1;
        }

        .canvas-container {
            flex: 2;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            width: 100%;
            height: 100%;
        }

        .controls-panel {
            flex: 1;
            background: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
            gap: 20px;
            min-width: 300px;
            overflow-y: auto;
        }

        .info-box {
            background-color: #e3f2fd;
            border-left: 5px solid #2196f3;
            padding: 15px;
            border-radius: 4px;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .formula-display {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #333;
            white-space: pre-wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        label {
            font-weight: 600;
            color: #444;
            display: flex;
            justify-content: space-between;
        }

        input[type=range] {
            width: 100%;
            cursor: pointer;
        }

        .buttons-row {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button {
            padding: 10px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background 0.2s;
            flex: 1;
        }

        button.btn-bisector {
            background-color: #4caf50;
            color: white;
        }
        button.btn-bisector:hover { background-color: #43a047; }

        button.btn-reset {
            background-color: #9e9e9e;
            color: white;
        }
        button.btn-reset:hover { background-color: #757575; }

        @media (max-width: 800px) {
            .main-container { flex-direction: column; }
            .canvas-container { height: 400px; }
        }
    </style>
</head>
<body>

<header>
    <h1>Simulação Fisicamente Correta de Espelhos Angulares</h1>
</header>

<div class="main-container">
    <div class="canvas-container" id="canvasWrapper">
        <canvas id="simCanvas"></canvas>
    </div>

    <div class="controls-panel">
        <div class="info-box">
            <div id="statsInfo"></div>
            <hr style="border: 0; border-top: 1px solid #bdc3c7; margin: 10px 0;">
            <div class="formula-display" id="formulaInfo"></div>
        </div>

        <div class="control-group">
            <label>
                Ângulo entre espelhos (&theta;)
                <span id="valTheta">60°</span>
            </label>
            <input type="range" id="sliderTheta" min="1" max="180" value="60" step="1">
        </div>

        <div class="control-group">
            <label>
                Ângulo do Objeto
                <span id="valObjAngle">30°</span>
            </label>
            <input type="range" id="sliderObjAngle" min="0" max="360" value="30" step="0.5">
        </div>

        <div class="control-group">
            <label>
                Distância (Raio)
                <span id="valRadius">3.0</span>
            </label>
            <input type="range" id="sliderRadius" min="0.5" max="4.5" value="3.0" step="0.1">
        </div>

        <div class="buttons-row">
            <button class="btn-bisector" id="btnBisector">Colocar na Bissetriz</button>
            <button class="btn-reset" id="btnReset">Resetar</button>
        </div>
    </div>
</div>

<script>
    // --- Configuração e Estado ---
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvasWrapper');

    // Elementos da UI
    const sliderTheta = document.getElementById('sliderTheta');
    const sliderObjAngle = document.getElementById('sliderObjAngle');
    const sliderRadius = document.getElementById('sliderRadius');
    const valTheta = document.getElementById('valTheta');
    const valObjAngle = document.getElementById('valObjAngle');
    const valRadius = document.getElementById('valRadius');
    const statsInfo = document.getElementById('statsInfo');
    const formulaInfo = document.getElementById('formulaInfo');
    const btnBisector = document.getElementById('btnBisector');
    const btnReset = document.getElementById('btnReset');

    // Estado da simulação
    let state = {
        thetaDeg: 60,
        objAngleDeg: 30,
        radius: 3.0,
        scale: 40, // Pixels por unidade
        width: 0,
        height: 0
    };

    // --- Funções Matemáticas Auxiliares ---

    function toRadians(deg) { return deg * Math.PI / 180; }
    function toDegrees(rad) { return rad * 180 / Math.PI; }

    function isOnBisector(objAngle, theta) {
        const bisector = theta / 2.0;
        // Tolerância de 0.5 graus conforme o código Python original
        return Math.abs(objAngle - bisector) < 0.5;
    }

    // Lógica principal de contagem de imagens (Portado do Python)
    function calculateNumberOfImages(thetaDeg, objOnBisector) {
        const ratio = 360.0 / thetaDeg;
        const N_int = Math.floor(ratio);
        
        // Verifica divisor exato com pequena tolerância para float
        const isExactDivisor = Math.abs(ratio - N_int) < 1e-10;
        
        let N, formula;

        if (isExactDivisor) {
            // Caso 1: Divisor exato (N par, pois 360 é par)
            // Se N_int é par, N = N_int - 1
            // Se N_int é impar e divisor exato, tecnicamente não acontece com 360 inteiro,
            // mas a regra "física" geralmente é N_int - 1 para divisores pares inteiros.
            // O código Python simplificava assumindo N = N_int - 1 sempre que exato.
            
            // Nota: Se 360/theta é par inteiro -> N = Ratio - 1
            // Se 360/theta é impar inteiro -> Objeto na bissetriz? 
            // O código Python original usava uma simplificação. Vamos seguir a lógica do Python fornecido:
            N = N_int - 1;
            formula = `360°/${thetaDeg}° = ${N_int} (exato)\nN = ${N_int} - 1 = ${N}`;
        } else {
            // Caso 2: Não é divisor exato (ou ímpar fracionário)
            N = N_int; // Parte inteira
            formula = `360°/${thetaDeg}° ≈ ${ratio.toFixed(2)}\nN = int(${ratio.toFixed(2)}) = ${N}`;
        }

        return { N, formula, isExactDivisor };
    }

    // --- Motor de Física (Reflexões) ---

    function calculateAllImages() {
        const thetaRad = toRadians(state.thetaDeg);
        const objRad = toRadians(state.objAngleDeg);
        
        // Posição do objeto original
        const objX = state.radius * Math.cos(objRad);
        const objY = state.radius * Math.sin(objRad);

        const onBisector = isOnBisector(state.objAngleDeg, state.thetaDeg);
        const { N: N_theory, formula } = calculateNumberOfImages(state.thetaDeg, onBisector);

        if (N_theory <= 0) {
            return { images: [], N_theory, formula, onBisector, obj: {x: objX, y: objY} };
        }

        // BFS para encontrar imagens
        let images = [];
        let imageSet = new Set(); // Para evitar duplicatas baseada em string de coords arredondadas
        
        // Adiciona objeto ao set para não duplicar com ele mesmo
        const key = (x, y) => `${x.toFixed(4)},${y.toFixed(4)}`;
        imageSet.add(key(objX, objY));

        // Fila de processamento: [x, y, angulo_atual]
        // Angulo atual é o ângulo polar do ponto
        let toProcess = [{x: objX, y: objY, angle: objRad}];
        
        const mirror1Angle = 0;
        const mirror2Angle = thetaRad;

        let safetyCount = 0;
        
        // Loop até encontrar o número teórico ou esgotar reflexões possíveis
        while (images.length < N_theory && toProcess.length > 0 && safetyCount < 1000) {
            const current = toProcess.shift();
            safetyCount++;

            // Tenta refletir nos dois espelhos
            // Fórmulas de reflexão polar: novo_angulo = 2*angulo_espelho - angulo_atual
            
            const reflections = [
                { mAngle: mirror1Angle },
                { mAngle: mirror2Angle }
            ];

            reflections.forEach(ref => {
                const newAngle = 2 * ref.mAngle - current.angle;
                // Normaliza ângulo
                const xNew = state.radius * Math.cos(newAngle);
                const yNew = state.radius * Math.sin(newAngle);
                
                const k = key(xNew, yNew);
                
                if (!imageSet.has(k)) {
                    // Verifica se não é o objeto original (redundância por segurança float)
                    const distToObj = Math.hypot(xNew - objX, yNew - objY);
                    
                    if (distToObj > 1e-4) {
                        imageSet.add(k);
                        const newImg = {x: xNew, y: yNew, angle: newAngle};
                        images.push(newImg);
                        toProcess.push(newImg); // Adiciona na fila para gerar reflexões de ordem superior
                    }
                }
            });
        }

        // Limita ao número teórico (física real vs artefatos numéricos)
        if (images.length > N_theory) {
            images = images.slice(0, N_theory);
        }

        return { images, N_theory, formula, onBisector, obj: {x: objX, y: objY} };
    }

    // --- Renderização ---

    // Converte coordenadas do mundo (física) para coordenadas do canvas
    function worldToScreen(x, y) {
        const cx = state.width / 2;
        const cy = state.height / 2;
        return {
            x: cx + x * state.scale,
            y: cy - y * state.scale // Y invertido no canvas
        };
    }

    function drawGrid() {
        const cx = state.width / 2;
        const cy = state.height / 2;
        
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        
        // Grid lines
        const step = state.scale;
        
        // Verticais
        for (let x = cx % step; x < state.width; x += step) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, state.height); ctx.stroke();
        }
        // Horizontais
        for (let y = cy % step; y < state.height; y += step) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(state.width, y); ctx.stroke();
        }

        // Eixos X e Y
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.moveTo(0, cy); ctx.lineTo(state.width, cy); ctx.stroke(); // X
        ctx.beginPath(); ctx.moveTo(cx, 0); ctx.lineTo(cx, state.height); ctx.stroke(); // Y
        
        // Marcador de origem
        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(cx, cy, 4, 0, Math.PI*2); ctx.fill();
    }

    function drawMirrors() {
        const center = worldToScreen(0, 0);
        const length = 5; // Comprimento visual do espelho

        // Espelho 1 (Fixo no eixo X positivo)
        const m1End = worldToScreen(length, 0);
        ctx.strokeStyle = 'blue';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(m1End.x, m1End.y);
        ctx.stroke();
        
        // Texto M1
        ctx.fillStyle = 'blue';
        ctx.font = 'bold 14px Arial';
        ctx.fillText("Espelho 1", m1End.x - 60, m1End.y + 20);

        // Espelho 2
        const thetaRad = toRadians(state.thetaDeg);
        const m2x = length * Math.cos(thetaRad);
        const m2y = length * Math.sin(thetaRad);
        const m2End = worldToScreen(m2x, m2y);
        
        ctx.strokeStyle = 'red';
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(m2End.x, m2End.y);
        ctx.stroke();

        // Texto M2
        ctx.fillStyle = 'red';
        ctx.fillText("Espelho 2", m2End.x + 5, m2End.y);

        // Bissetriz
        const bisAngle = thetaRad / 2;
        const bx = (length - 1) * Math.cos(bisAngle);
        const by = (length - 1) * Math.sin(bisAngle);
        const bEnd = worldToScreen(bx, by);

        ctx.strokeStyle = 'green';
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(center.x, center.y);
        ctx.lineTo(bEnd.x, bEnd.y);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = 'green';
        ctx.font = '12px Arial';
        ctx.fillText("Bissetriz", bEnd.x + 5, bEnd.y);
    }

    function drawScene() {
        // Limpar
        ctx.clearRect(0, 0, state.width, state.height);
        
        drawGrid();
        drawMirrors();

        // Calcular Física
        const data = calculateAllImages();
        
        // Desenhar Imagens
        data.images.forEach((img, index) => {
            const pos = worldToScreen(img.x, img.y);
            
            // Quadrado azul
            ctx.fillStyle = 'rgba(33, 150, 243, 0.3)';
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            const size = 12;
            ctx.fillRect(pos.x - size, pos.y - size, size*2, size*2);
            ctx.strokeRect(pos.x - size, pos.y - size, size*2, size*2);

            // Número
            ctx.fillStyle = 'black';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            // Fundo amarelo do número
            const textW = 14;
            ctx.fillStyle = 'rgba(255, 235, 59, 0.8)';
            ctx.fillRect(pos.x + 8, pos.y + 8, textW, textW);
            ctx.fillStyle = 'black';
            ctx.fillText(index + 1, pos.x + 15, pos.y + 15);
        });

        // Desenhar Objeto Original
        const objPos = worldToScreen(data.obj.x, data.obj.y);
        ctx.beginPath();
        ctx.arc(objPos.x, objPos.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'black';
        ctx.stroke();
        
        ctx.fillStyle = 'black';
        ctx.font = 'bold 12px Arial';
        ctx.fillText("Obj", objPos.x, objPos.y - 12);

        // Atualizar UI de Texto
        updateInfoPanel(data);
    }

    function updateInfoPanel(data) {
        statsInfo.innerHTML = `
            <strong>Ângulo entre espelhos:</strong> ${state.thetaDeg}°<br>
            <strong>Ângulo do Objeto:</strong> ${state.objAngleDeg.toFixed(1)}°<br>
            <strong>Na bissetriz:</strong> ${data.onBisector ? '<span style="color:green; font-weight:bold">SIM</span>' : 'NÃO'}<br>
            <br>
            <strong>Imagens Teóricas (N):</strong> ${data.N_theory}<br>
            <strong>Imagens Visíveis:</strong> ${data.images.length}
        `;
        
        formulaInfo.innerText = data.formula;
    }

    // --- Manipuladores de Eventos ---

    function resize() {
        // Ajusta tamanho do canvas ao container
        const rect = container.getBoundingClientRect();
        canvas.width = rect.width;
        canvas.height = rect.height;
        state.width = rect.width;
        state.height = rect.height;
        
        // Ajusta escala baseada no menor lado
        state.scale = Math.min(state.width, state.height) / 11; // -5 a +5 = 10 unidades + margem
        
        drawScene();
    }

    function updateParams() {
        state.thetaDeg = parseInt(sliderTheta.value);
        state.objAngleDeg = parseFloat(sliderObjAngle.value);
        state.radius = parseFloat(sliderRadius.value);

        // Atualiza labels
        valTheta.textContent = state.thetaDeg + "°";
        valObjAngle.textContent = state.objAngleDeg.toFixed(1) + "°";
        valRadius.textContent = state.radius.toFixed(1);

        drawScene();
    }

    // Listeners Sliders
    sliderTheta.addEventListener('input', updateParams);
    sliderObjAngle.addEventListener('input', updateParams);
    sliderRadius.addEventListener('input', updateParams);

    // Listeners Botões
    btnBisector.addEventListener('click', () => {
        const newAngle = state.thetaDeg / 2.0;
        sliderObjAngle.value = newAngle;
        updateParams();
    });

    btnReset.addEventListener('click', () => {
        sliderTheta.value = 60;
        sliderObjAngle.value = 30;
        sliderRadius.value = 3.0;
        updateParams();
    });

    window.addEventListener('resize', resize);

    // Inicialização
    resize(); // Configura tamanho inicial e desenha
    updateParams(); // Garante sincronia inicial

</script>

</body>
</html>
